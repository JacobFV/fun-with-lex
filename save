## ./tokens.h
```
// CMSC 430 Compiler Theory and Design
// Project 1 Skeleton
// UMGC CITE
// Summer 2023

// This file contains the enumerated type definition for tokens

enum Tokens {ADDOP = 256, MULOP, ANDOP, RELOP, ARROW, BEGIN_, CASE, CHARACTER, END,
     ENDSWITCH, FUNCTION, INTEGER, IS, LIST, OF, OTHERS, RETURNS, SWITCH, WHEN,
     IDENTIFIER, INT_LITERAL, CHAR_LITERAL};
```
## ./README.md
```
# Compile and run

```bash
make scanner.c
make compile
./compile < test1.txt
cat lexemes.txt
```

Read the `docs/Directions` and `docs/Suggestions` files for more information.
```
## ./docs/Directions
```
                                  CMSC 430 Project 1
The first project involves modifying the attached lexical analyzer and the compilation listing
generator code. You need to make the following modifications to the lexical analyzer,
scanner.l:

   1. The following reserved words should be added:

       else, elsif, endfold, endif, fold, if, left, real, right, then

       Each reserved words should be a separate token. The token name should be the same as
       the lexeme, but in all upper case.

   2. Two additional logical operators should be added. The lexeme for the first should be |
       and its token should be OROP. The second logical operator added should be ! and its token
       should be NOTOP.
   3. Five relational operators should be added. They are =, <>, >, >= and <=. All of the
       lexemes should be represented by the single token RELOP.
   4. One additional lexeme should be added for the ADDOP token. It is binary operator – that is
       the subtraction operator.
   5. One additional lexeme should be added for the MULOP token. It is/ that is the division
       operator.
   6. A new token REMOP should be added for the remainder operator. Its lexeme should be %.
   7. A new token EXPOP should be added for the exponentiation operator. Its lexeme should
       be ^.
   8. A new token NEGOP should be added for the unary minus operator. Its lexeme should be
       ~.
   9. A second type of comment should be added that begins with -- and ends with the end of
       line. As with the existing comment, no token should be returned.
   10. The definition for the identifiers should be modified so that underscores can be included,
       however, no more than two consecutive underscores are permitted, but leading and
       trailing underscores should not be permitted.
   11. One additional type of integer literal should be added, which are hexadecimal integers.
       The begin with the # character followed by one of more decimal digits, or the letter A-F,
       in either upper or lower case.
   12. A real literal token should be added. It should begin with a sequence of zero or more
       digits following by a decimal point followed by one or more additional digits. It may
       optionally end with an exponent. If present, the exponent should begin with an e or E,
       followed by an optional plus or minus sign followed by one or more digits.
   13. The definition for the character literals should be modified so that five additional escape
       characters are also allowed: '', '	', '
', '' and ''.

You must also modify the header file tokens.h to include each the new tokens mentioned
above.

The compilation listing generator code should be modified as follows:
   1. The lastLine function should be modified to compute the total number of errors. If any
      errors occurred the number of lexical, syntactic and semantic errors should be displayed.
      If no errors occurred, it should display Compiled Successfully. It should return the
      total number of errors.
   2. The appendError function should be modified to count the number of lexical, syntactic
      and semantic errors. The error message passed to it should be added to a queue of
      messages that occurred on that line.
   3. The displayErrors function should be modified to display all the error messages that
      have occurred on the previous line and then clear the queue of messages.

An example of the output of a program with no lexical errors is shown below:

   1   // Function with Arithmetic Expression
   2
   3   function main returns integer;
   4   begin
   5        7 + 2 * (5 + 4);
   6   end;

Compiled Successfully

Here is the required output for a program that contains more than one lexical error on the same
line:

   1 // Function with Two Lexical Errors
   2
   3 function main returns integer;
   4 begin
   5      7 $ 2 ? (2 + 4);
Lexical Error, Invalid Character $
Lexical Error, Invalid Character ?
   6 end;

Lexical Errors 2
Syntax Errors 0
Semantic Errors 0

You are to submit two files.

   1. The first is a .zip file that contains all the source code for the project. The .zip file
      should contain the flex input file, which should be a .l file, all .cc and .h files and a
      makefile that builds the project.
   2. The second is a Word document (PDF or RTF is also acceptable) that contains the
      documentation for the project, which should include the following:
         a. A discussion of how you approached the project
         b. A test plan that includes test cases that you have created indicating what aspects
              of the program each one is testing and a screen shot of your compiler run on that
              test case
         c. A discussion of lessons learned from the project and any improvements that could
              be made

```
## ./docs/Suggestions
```
Here is the recommended approach for project 1.

1) First build the skeleton for project 1 as shown in part 5 of the video series on lexical analysis
using the make file provided. Then run it on the test cases test1.txt – test3.txt that are
provided in Project 1 Test Data and be sure that you understand how it works. Examine the
contents of lexemes.txt, so that you see the lexeme-token pairs that it contains.
2) A good starting point would be item 1 in the requirements, which includes the additional
reserved words of the language. Each of these is a separate token and requires a separate
translation rule. Examine the existing translation rules for the reserved words as an example of
how to proceed. In addition, add the token names for each one to the enumerated type Tokens in
tokens.h. The order in which you add them is unimportant. Rebuild the program with the make
file to ensure that it builds correctly.
Use test4.txt to test this modification. Shown below is the output that should result when
using that test case as input:
   1   // Function with All Reserved Words
   2
   3   function main returns character;
   4        number: real is when 2 < 3, 0 : 1;
   5        values: list of integer is (4, 5, 6);
   6   begin
   7        if number < 6.3 then
   8             fold left + (1, 2, 3) endfold;
   9        elsif 6 < 7 then
  10             fold right + values endfold;
  11        else
  12             switch a is
  13                 case 1 => number + 2;
  14                 case 2 => number * 3;
  15                 others => number;
  16             endswitch;
  17        endif;
  18   end;

Compiled Successfully

You should receive no lexical errors. At this point, you should also examine lexemes.txt to see
each new reserved word has a unique token number.
3) Adding all the operators as specified by items 2-8 in the requirements would be a good next
step. Examine the existing translation rules for the existing operators as an example of how to
proceed. As before, you must also add the token names for each new operator to the enumerated
type Tokens in tokens.h.
Use test5.txt to test this modification. Shown below is the output that should result when
using that test case as input:
$ ./compile < test7.txt
   1   // Program Containing the New Operators
   2
   3   function main b: integer, c: integer returns integer;
   4         a: integer is 3;
   5   begin
   6        if (a < 2) | (a > 0) & (~b <> 0) then
   7             7 - 2 / (9 % 4);
   8        else
   9             if b >= 2 | b <= 6 & !(c = 1) then
  10                  7 + 2 * (2 + 4);
  11             else
  12                  a ^ 2;
  13             endif;
  14        endif;
  15   end;

Compiled Successfully

As before, you should receive no lexical errors. At this point, you may again want to examine
lexemes.txt to see that each new operator has the appropriate token number.

4) As the last modification to scanner.l and tokens.h, add the new comment, modify the
identifier and character literal tokens and add the real literal, and hexadecimal integer literal
tokens as specified by items 9-13 in the requirements.
Use test6.txt to test this modification. Shown below is the output that should result when
using that test case as input:
   1   // Program Containing the New Comment, Modified Identifier
   2   //     and Real Literal and Hex and Character Literals
   3
   4   -- This is the new style comment
   5
   6   function main b: integer, c: integer returns integer;
   7         a: real is .3;
   8         d: real is 5.7;
   9         a__1: real is .4e2;
  10         ab_c_d: real is 4.3E+1;
  11         ab1_cd2: real is 4.5e-1;
  12         hex: integer is #2aF;
  13         char1: character is 'C';
  14         char2: character is '
';
  15   begin
  16         hex + 2;
  17   end;

Compiled Successfully

As before, you should receive no lexical errors.
5) The final required change is to modify the three functions that generate the compilation listing
as described in the requirements so that the number of errors are displayed at the end if any
occur, or the message Compilation Successful is displayed if none occur. In addition, the
modifications should ensure that all the error messages that have occurred on the previous line
are displayed. Rerunning any of the previous test cases should confirm that the Compilation
Successful is displayed.
Use test7.txt to test whether multiple lexical errors on the same line are displayed. Shown
below is the output that should result when using that test case as input:
$ ./compile < test9.txt

   1 // Function with two lexical errors
   2
   3 function main returns integer;
   4 begin
   5      7 $ 2 ? (2 + 4);
Lexical Error, Invalid Character $
Lexical Error, Invalid Character ?
   6 end;

Lexical Errors 2
Syntax Errors 0


6) As a final test, test8.txt contains every punctuation symbol, reserved word, operator and
both valid and invalid identifiers. Shown below is the output that should result when using that
test case as input:
$ ./compile < test10.txt

   1 -- Punctuation symbols
   2
   3 ,:;() =>
   4
   5 // Valid identifiers
   6
   7 name_1
   8 name_1__a2_ab3
   9
  10 // Invalid identifiers
  11
  12 name___2
Lexical Error, Invalid Character _
Lexical Error, Invalid Character _
Lexical Error, Invalid Character _
  13 _name3
Lexical Error, Invalid Character _
  14 name4_
Lexical Error, Invalid Character _
  15
  16 // Integer Literals
  17
  18 23 #3aD
  19
  20 // Real Literals
  21
  22 123.45 .123 1.2E2 .1e+2 1.2E-2
  23
  24 // Character Literals
  25
  26   'A' '
'
  27
  28   // Logical operators
  29
  30   & | !
  31
  32   // Relational operators
  33
  34   = <> > >= < <=
  35
  36   // Arithmetic operators
  37
  38   + - * / % ^ ~
  39
  40   // Reserved words
  41
  42   begin case character else elsif end endcase endfold endif endswitch
  43   fold function if integer is left list of others real returns right
  44   switch then when

Lexical Errors 5
Syntax Errors 0
Semantic Errors 0

In addition to verifying that your lexical analyzer generates the same lexical errors, you should
also examine the lexemes.txt file generated to be sure that every lexeme has the proper token
associated with it.
All of the test cases discussed above are included in the attached .zip file. In addition, the
lexemes.txt file from the final test case is included to compare with yours. Keep in mind that
the actual token numbers will depend on the order of your Tokens enumerated type, so they may
not exactly match.
You are certainly encouraged to create any other test cases that you wish to incorporate in your
test plan. Keep in mind that your scanner should generate a lexical error for any input program
that contains one, so it is recommended that you choose some different test cases as a part of
your test plan. A comparable but different set of test cases may be used when testing your
project.

```
## ./.vscode/settings.json
```
{
  "files.associations": {
    "save": "c"
  }
}
```
## ./makefile
```
compile: scanner.o listing.o
	g++ -o compile scanner.o listing.o

scanner.o: scanner.c listing.h tokens.h
	g++ -c scanner.c

scanner.c: scanner.l
	flex scanner.l
	mv lex.yy.c scanner.c

listing.o: listing.cc listing.h
	g++ -c listing.cc
```
## ./save
```
## ./tokens.h
```
// CMSC 430 Compiler Theory and Design
// Project 1 Skeleton
// UMGC CITE
// Summer 2023

// This file contains the enumerated type definition for tokens

enum Tokens {ADDOP = 256, MULOP, ANDOP, RELOP, ARROW, BEGIN_, CASE, CHARACTER, END,
     ENDSWITCH, FUNCTION, INTEGER, IS, LIST, OF, OTHERS, RETURNS, SWITCH, WHEN,
     IDENTIFIER, INT_LITERAL, CHAR_LITERAL};
```
## ./README.md
```
# Compile and run

```bash
make scanner.c
make compile
./compile < test1.txt
cat lexemes.txt
```

Read the `docs/Directions` and `docs/Suggestions` files for more information.
```
## ./docs/Directions
```
                                  CMSC 430 Project 1
The first project involves modifying the attached lexical analyzer and the compilation listing
generator code. You need to make the following modifications to the lexical analyzer,
scanner.l:

   1. The following reserved words should be added:

       else, elsif, endfold, endif, fold, if, left, real, right, then

       Each reserved words should be a separate token. The token name should be the same as
       the lexeme, but in all upper case.

   2. Two additional logical operators should be added. The lexeme for the first should be |
       and its token should be OROP. The second logical operator added should be ! and its token
       should be NOTOP.
   3. Five relational operators should be added. They are =, <>, >, >= and <=. All of the
       lexemes should be represented by the single token RELOP.
   4. One additional lexeme should be added for the ADDOP token. It is binary operator – that is
       the subtraction operator.
   5. One additional lexeme should be added for the MULOP token. It is/ that is the division
       operator.
   6. A new token REMOP should be added for the remainder operator. Its lexeme should be %.
   7. A new token EXPOP should be added for the exponentiation operator. Its lexeme should
       be ^.
   8. A new token NEGOP should be added for the unary minus operator. Its lexeme should be
       ~.
   9. A second type of comment should be added that begins with -- and ends with the end of
       line. As with the existing comment, no token should be returned.
   10. The definition for the identifiers should be modified so that underscores can be included,
       however, no more than two consecutive underscores are permitted, but leading and
       trailing underscores should not be permitted.
   11. One additional type of integer literal should be added, which are hexadecimal integers.
       The begin with the # character followed by one of more decimal digits, or the letter A-F,
       in either upper or lower case.
   12. A real literal token should be added. It should begin with a sequence of zero or more
       digits following by a decimal point followed by one or more additional digits. It may
       optionally end with an exponent. If present, the exponent should begin with an e or E,
       followed by an optional plus or minus sign followed by one or more digits.
   13. The definition for the character literals should be modified so that five additional escape
       characters are also allowed: '', '	', '
', '' and ''.

You must also modify the header file tokens.h to include each the new tokens mentioned
above.

The compilation listing generator code should be modified as follows:
   1. The lastLine function should be modified to compute the total number of errors. If any
      errors occurred the number of lexical, syntactic and semantic errors should be displayed.
      If no errors occurred, it should display Compiled Successfully. It should return the
      total number of errors.
   2. The appendError function should be modified to count the number of lexical, syntactic
      and semantic errors. The error message passed to it should be added to a queue of
      messages that occurred on that line.
   3. The displayErrors function should be modified to display all the error messages that
      have occurred on the previous line and then clear the queue of messages.

An example of the output of a program with no lexical errors is shown below:

   1   // Function with Arithmetic Expression
   2
   3   function main returns integer;
   4   begin
   5        7 + 2 * (5 + 4);
   6   end;

Compiled Successfully

Here is the required output for a program that contains more than one lexical error on the same
line:

   1 // Function with Two Lexical Errors
   2
   3 function main returns integer;
   4 begin
   5      7 $ 2 ? (2 + 4);
Lexical Error, Invalid Character $
Lexical Error, Invalid Character ?
   6 end;

Lexical Errors 2
Syntax Errors 0
Semantic Errors 0

You are to submit two files.

   1. The first is a .zip file that contains all the source code for the project. The .zip file
      should contain the flex input file, which should be a .l file, all .cc and .h files and a
      makefile that builds the project.
   2. The second is a Word document (PDF or RTF is also acceptable) that contains the
      documentation for the project, which should include the following:
         a. A discussion of how you approached the project
         b. A test plan that includes test cases that you have created indicating what aspects
              of the program each one is testing and a screen shot of your compiler run on that
              test case
         c. A discussion of lessons learned from the project and any improvements that could
              be made

```
## ./docs/Suggestions
```
Here is the recommended approach for project 1.

1) First build the skeleton for project 1 as shown in part 5 of the video series on lexical analysis
using the make file provided. Then run it on the test cases test1.txt – test3.txt that are
provided in Project 1 Test Data and be sure that you understand how it works. Examine the
contents of lexemes.txt, so that you see the lexeme-token pairs that it contains.
2) A good starting point would be item 1 in the requirements, which includes the additional
reserved words of the language. Each of these is a separate token and requires a separate
translation rule. Examine the existing translation rules for the reserved words as an example of
how to proceed. In addition, add the token names for each one to the enumerated type Tokens in
tokens.h. The order in which you add them is unimportant. Rebuild the program with the make
file to ensure that it builds correctly.
Use test4.txt to test this modification. Shown below is the output that should result when
using that test case as input:
   1   // Function with All Reserved Words
   2
   3   function main returns character;
   4        number: real is when 2 < 3, 0 : 1;
   5        values: list of integer is (4, 5, 6);
   6   begin
   7        if number < 6.3 then
   8             fold left + (1, 2, 3) endfold;
   9        elsif 6 < 7 then
  10             fold right + values endfold;
  11        else
  12             switch a is
  13                 case 1 => number + 2;
  14                 case 2 => number * 3;
  15                 others => number;
  16             endswitch;
  17        endif;
  18   end;

Compiled Successfully

You should receive no lexical errors. At this point, you should also examine lexemes.txt to see
each new reserved word has a unique token number.
3) Adding all the operators as specified by items 2-8 in the requirements would be a good next
step. Examine the existing translation rules for the existing operators as an example of how to
proceed. As before, you must also add the token names for each new operator to the enumerated
type Tokens in tokens.h.
Use test5.txt to test this modification. Shown below is the output that should result when
using that test case as input:
$ ./compile < test7.txt
   1   // Program Containing the New Operators
   2
   3   function main b: integer, c: integer returns integer;
   4         a: integer is 3;
   5   begin
   6        if (a < 2) | (a > 0) & (~b <> 0) then
   7             7 - 2 / (9 % 4);
   8        else
   9             if b >= 2 | b <= 6 & !(c = 1) then
  10                  7 + 2 * (2 + 4);
  11             else
  12                  a ^ 2;
  13             endif;
  14        endif;
  15   end;

Compiled Successfully

As before, you should receive no lexical errors. At this point, you may again want to examine
lexemes.txt to see that each new operator has the appropriate token number.

4) As the last modification to scanner.l and tokens.h, add the new comment, modify the
identifier and character literal tokens and add the real literal, and hexadecimal integer literal
tokens as specified by items 9-13 in the requirements.
Use test6.txt to test this modification. Shown below is the output that should result when
using that test case as input:
   1   // Program Containing the New Comment, Modified Identifier
   2   //     and Real Literal and Hex and Character Literals
   3
   4   -- This is the new style comment
   5
   6   function main b: integer, c: integer returns integer;
   7         a: real is .3;
   8         d: real is 5.7;
   9         a__1: real is .4e2;
  10         ab_c_d: real is 4.3E+1;
  11         ab1_cd2: real is 4.5e-1;
  12         hex: integer is #2aF;
  13         char1: character is 'C';
  14         char2: character is '
';
  15   begin
  16         hex + 2;
  17   end;

Compiled Successfully

As before, you should receive no lexical errors.
5) The final required change is to modify the three functions that generate the compilation listing
as described in the requirements so that the number of errors are displayed at the end if any
occur, or the message Compilation Successful is displayed if none occur. In addition, the
modifications should ensure that all the error messages that have occurred on the previous line
are displayed. Rerunning any of the previous test cases should confirm that the Compilation
Successful is displayed.
Use test7.txt to test whether multiple lexical errors on the same line are displayed. Shown
below is the output that should result when using that test case as input:
$ ./compile < test9.txt

   1 // Function with two lexical errors
   2
   3 function main returns integer;
   4 begin
   5      7 $ 2 ? (2 + 4);
Lexical Error, Invalid Character $
Lexical Error, Invalid Character ?
   6 end;

Lexical Errors 2
Syntax Errors 0


6) As a final test, test8.txt contains every punctuation symbol, reserved word, operator and
both valid and invalid identifiers. Shown below is the output that should result when using that
test case as input:
$ ./compile < test10.txt

   1 -- Punctuation symbols
   2
   3 ,:;() =>
   4
   5 // Valid identifiers
   6
   7 name_1
   8 name_1__a2_ab3
   9
  10 // Invalid identifiers
  11
  12 name___2
Lexical Error, Invalid Character _
Lexical Error, Invalid Character _
Lexical Error, Invalid Character _
  13 _name3
Lexical Error, Invalid Character _
  14 name4_
Lexical Error, Invalid Character _
  15
  16 // Integer Literals
  17
  18 23 #3aD
  19
  20 // Real Literals
  21
  22 123.45 .123 1.2E2 .1e+2 1.2E-2
  23
  24 // Character Literals
  25
  26   'A' '
'
  27
  28   // Logical operators
  29
  30   & | !
  31
  32   // Relational operators
  33
  34   = <> > >= < <=
  35
  36   // Arithmetic operators
  37
  38   + - * / % ^ ~
  39
  40   // Reserved words
  41
  42   begin case character else elsif end endcase endfold endif endswitch
  43   fold function if integer is left list of others real returns right
  44   switch then when

Lexical Errors 5
Syntax Errors 0
Semantic Errors 0

In addition to verifying that your lexical analyzer generates the same lexical errors, you should
also examine the lexemes.txt file generated to be sure that every lexeme has the proper token
associated with it.
All of the test cases discussed above are included in the attached .zip file. In addition, the
lexemes.txt file from the final test case is included to compare with yours. Keep in mind that
the actual token numbers will depend on the order of your Tokens enumerated type, so they may
not exactly match.
You are certainly encouraged to create any other test cases that you wish to incorporate in your
test plan. Keep in mind that your scanner should generate a lexical error for any input program
that contains one, so it is recommended that you choose some different test cases as a part of
your test plan. A comparable but different set of test cases may be used when testing your
project.

```
## ./.vscode/settings.json
```
{
  "files.associations": {
    "save": "c"
  }
}
```
## ./makefile
```
compile: scanner.o listing.o
	g++ -o compile scanner.o listing.o

scanner.o: scanner.c listing.h tokens.h
	g++ -c scanner.c

scanner.c: scanner.l
	flex scanner.l
	mv lex.yy.c scanner.c

listing.o: listing.cc listing.h
	g++ -c listing.cc
```
```
## ./scanner.l
```
/* CMSC 430 Compiler Theory and Design
   Project 1 Skeleton
   UMGC CITE
   Summer 2023 */

/* This file contains flex input file */

%{
#include <cstdio>
#include <string>

using namespace std;

#include "listing.h"
#include "tokens.h"

%}

%option noyywrap

ws		[ 	]+
comment		"//".*

line		[
]
id		[A-Za-z]([A-Za-z0-9])*
digit		[0-9]
dec		{digit}+
char		'.'
punc		[\(\),:;]
%%

{ws}		{ ECHO; }
{comment}	{ ECHO; nextLine(); }
{line}		{ ECHO; nextLine(); }
"+"		{ ECHO; return(ADDOP); }
"*"		{ ECHO; return(MULOP); }
"&"		{ ECHO; return(ANDOP); }
"<"		{ ECHO; return(RELOP); }
"=>"		{ ECHO; return(ARROW); }
begin		{ ECHO; return(BEGIN_); }
case		{ ECHO; return(CASE); }
character	{ ECHO; return(CHARACTER); }
end		{ ECHO; return(END); }
endswitch	{ ECHO; return(ENDSWITCH); }
function	{ ECHO; return(FUNCTION); }
integer		{ ECHO; return(INTEGER); }
is		{ ECHO; return(IS); }
list		{ ECHO; return(LIST); }
of		{ ECHO; return(OF); }
others		{ ECHO; return(OTHERS); }
returns		{ ECHO; return(RETURNS); }
switch		{ ECHO; return(SWITCH); }
when		{ ECHO; return(WHEN); }

{id}		{ ECHO; return(IDENTIFIER);}
{dec}		{ ECHO; return(INT_LITERAL); }
{char}		{ ECHO; return(CHAR_LITERAL); }
{punc}		{ ECHO; return(yytext[0]); }
.		{ ECHO; appendError(LEXICAL, yytext); }
%%

int main() {
	firstLine();
	
	FILE *file = fopen("lexemes.txt", "wa"); 
	int token = yylex();
	while (token) {
		fprintf(file, "%d %s
", token, yytext);
		token = yylex();
	}
	lastLine();
	fclose(file);
	return 0;
}
```
## ./listing.h
```
// CMSC 430 Compiler Theory and Design
// Project 1 Skeleton
// UMGC CITE
// Summer 2023

// This file contains the function prototypes for the functions that produce
// the compilation listing

enum ErrorCategories {LEXICAL, SYNTAX, GENERAL_SEMANTIC, DUPLICATE_IDENTIFIER,
	UNDECLARED};

void firstLine();
void nextLine();
int lastLine();
void appendError(ErrorCategories errorCategory, string message);

```
## ./.gitignore
```
scanner.c
scanner.o
compile
lexemes.txt
```
## ./tests/test3.txt
```
// Punctuation symbols

,;() =>

// Identifier

name name123 

// Literals

123 'a'

// Logical operator

&

// Relational operator

<

// Arithmetic operators

+ *

// Reserved words

begin case character end endswitch function is integer list of returns switch when
```
## ./tests/test4.txt
```
// Function with All Reserved Words

function main returns character;
    number: real is when 2 < 3, 0 : 1;
    values: list of integer is (4, 5, 6);
begin
    if number < 6.3 then
        fold left + (1, 2, 3) endfold;
    elsif 6 < 7 then
        fold right + values endfold;
    else
        switch a is
            case 1 => number + 2;
            case 2 => number * 3;
            others => number;  
        endswitch;
    endif;    
end;
```
## ./tests/test2.txt
```
// Function with a lexical error

function main returns integer;
begin
    7 * 2 $ (2  + 4);
end;
```
## ./tests/test1.txt
```
// Function with Arithmetic Expression

function main returns integer;
begin
    7 + 2 * (5  + 4);
end;
```
## ./tests/test7.txt
```
// Function with Two Lexical Errors

function main returns integer;
begin
    7 $ 2 ? (2 + 4);
end;
```
## ./tests/test6.txt
```
// Program Containing the New Comment, Modified Identifier 
//     and Real Literal and Hex and Character Literals

-- This is the new style comment

function main b: integer, c: integer returns integer;
     a: real is .3;
     d: real is 5.7;
     a__1: real is .4e2;
     ab_c_d: real is 4.3E+1;
     ab1_cd2: real is 4.5e-1;
     hex: integer is #2aF;
     char1: character is 'C';
     char2: character is '
';
begin
     hex + 2;
end;
```
## ./tests/test5.txt
```
// Program Containing the New Operators

function main b: integer, c: integer returns integer;
     a: integer is 3;
begin
    if (a < 2) | (a > 0) & (~b <> 0) then
        7 - 2 / (9 % 4);
    else
        if b >= 2 | b <= 6 & !(c = 1) then
            7 + 2 * (2 + 4);
        else
            a ^ 2;
        endif;
    endif;
end;
```
## ./tests/test8.txt
```
-- Punctuation symbols

,:;() =>

// Valid identifiers

name_1
name_1__a2_ab3

// Invalid identifiers

name___2
_name3
name4_

// Integer Literals

23 #3aD

// Real Literals

123.45 .123 1.2E2 .1e+2 1.2E-2

// Character Literals

'A' '
'

// Logical operators

& | !

// Relational operators

= <> > >= < <=

// Arithmetic operators

+ - * / % ^ ~

// Reserved words

begin case character else elsif end endcase endfold endif endswitch 
fold function if integer is left list of others real returns right
switch then when
```
## ./listing.cc
```
// CMSC 430 Compiler Theory and Design
// Project 1 Skeleton
// UMGC CITE
// Summer 2023

// This file contains the bodies of the functions that produces the 
// compilation listing

#include <cstdio>
#include <string>

using namespace std;

#include "listing.h"

static int lineNumber;
static string error = "";
static int totalErrors = 0;

static void displayErrors();

void firstLine()
{
	lineNumber = 1;
	printf("
%4d  ",lineNumber);
}

void nextLine()
{
	displayErrors();
	lineNumber++;
	printf("%4d  ",lineNumber);
}

int lastLine()
{
	printf("");
	displayErrors();
	printf("     
");
	return totalErrors;
}
    
void appendError(ErrorCategories errorCategory, string message)
{
	string messages[] = { "Lexical Error, Invalid Character ", "",
		"Semantic Error, ", "Semantic Error, Duplicate ",
		"Semantic Error, Undeclared " };

	error = messages[errorCategory] + message;
	totalErrors++;
}

void displayErrors()
{
	if (error != "")
		printf("%s
", error.c_str());
	error = "";
}
```
